<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<HTML VERSION="2.0">
<HEAD>
<TITLE>Component Documentation</TITLE>
</HEAD>
<BODY BGCOLOR="#ffffff">

<H1><IMG SRC="ada95lgo.gif" ALT="Component Documentation"></H1>
<P><I>An Overview of the Booch Components for Ada95</I> </P>
<P><A HREF="#abstractions">Key Abstractions</A><BR>
 <A HREF="#patterns">The Patterns of the BCs</A><BR>
 <A HREF="#tactical">Tactical Issues</A><BR>
 <A HREF="#macro">Macro Organization</A><BR>
 <A HREF="#families">Class Families</A><BR>
 <A HREF="#micro">Micro Organization</A><BR>
 <A HREF="#timeandspace">Time and Space Semantics</A><BR>
 <A HREF="#storage">Storage Management</A><BR>
 <A HREF="#exceptions">Exceptions</A><BR>
 <A HREF="#iteration">Iteration</A><BR>
 <A HREF="#conclusion">Conclusion</A><BR>
 </P>
<P><IMG SRC="greenline.gif" ALT="--" WIDTH="600" HEIGHT="4"> </P>
<P>


<!---------------------------------------------------------------------->


 </P>
<H2><A NAME="abstractions">Key Abstractions</A></H2>
<P>The Ada 95 verison of the components will contain the same key abstractions
as the C++ form (Tools, Support, and Structs). However, the organization
will be slightly different, particularly in the Support domain. This is
because Ada 95 provides several special forms of memory management that
are quite different from C++. </P>
<P>The Booch Components (BCs) are organized in three major areas: <B>Tools</B>, <B>Support</B>, and <B>Structs</B>. The <B>Tools</B> category provides algorithmic abstractions (Searching, Sorting, etc.).
The <B>Structs</B> category provides an array of structural abstractions (Bags, Collections,
Deques, Graphs, Lists, Maps, Queues, Rings, Sets, Stacks, Sequences, and
Trees). The <B>Support</B> category contains all the &quot;concrete&quot; forms, plus structures to create the
components. </P>
<P>Some of the structures permit structural sharing (graphs, lists, and trees).
Some structures may also be ordered (collections, dequeues, and queues).
There are also multiple forms for some structures: single and double llinked
lists, directed and undirected graphs, and binary, multiway, and AVL trees.


<!---------------------------------------------------------------------->


 </P>
<H2><A NAME="patterns">The Patterns of the BCs</A></H2>
<P>The BCs cover several issues: </P>
<UL>
<LI>Time and Space semantics 
<LI>Storage Management policies 
<LI>Exceptions 
<LI>Idioms for iteration 
<LI>Synchronization forms 
</UL>
<P>These patterns have evolved in a way that each language feature is used
in an efficient and appropriate manner, with the overall goal of balancing
usability and extensibility. 


<!---------------------------------------------------------------------->


 </P>
<H2><A NAME="tactical">Tactical Issues</A></H2>
<P></P>
<BLOCKQUOTE>The particular semantics of a given programming language influence our architectural
decisions. To ignore these influences leaves us with abstractions that do
not take advantage of the language's unique features, or with mechanisms
that cannot be efficiently implemented. -- <I>G. Booch</I> </BLOCKQUOTE>
<P>Ada 95 inherently provides several features not present in C++: user-defined
storage pools, automatic reclamation of resources (garbage collection &quot;lite&quot;),
general access types and access discriminants, and concurrency support.
All this as well as the C++ features of aggregation, inheritance, and parameterization. </P>
<P>The BCs take advantage of several critical forms of structuring: inheritance,
parameterization, modularity, concurrency, and aggregation. Of these forms,
parameterization is the form most often used. 


<!---------------------------------------------------------------------->


</P>
<H2><A NAME="macro">Macro Organization</A></H2>
<P>The BCs emphasize separation of policy from implementation. For this reason,
abstract classes are declared for every major component type. Also, the
Support category provides the same low-level features used in constructing
the different components, in order to help the &quot;power user&quot; create new components
or extend existing ones. </P>
<P>An example:<BR>
 A Mail_Queue is an instance of a Priority_Event_Queue, which itself is
a generic instantiated with Network_Event as the item it contains. The Priority_Event_Queue
is derived from Queue. 


<!---------------------------------------------------------------------->


 </P>
<H2><a name="families">Class Families</a></H2>
<P>Each abstract base class has several derived concrete forms, each designed
to support specific needs for time and space semantics. The user selects
the concrete form most appropriate to their needs. The net result is that
copy, assignment, and equality operations work between each different form
of the components. </P>
<P>There are two very common variations of structure management: bounded and
unbounded. A third form was added to the latest BCs: dynamic. This form
represents a heap structure which behaves (basically) as a dynamic array.
Its performance lies between that of a bounded and unbounded structure.
The array can grow or shrink in multiples of a chunk_size. </P>
<P>The selection rules are: </P>
<DL>
<DT><B>Bounded</B> 
<DD>Use where size is statically known or allocation from the heap is prohibited. 
<DT><B>Dynamic</B> 
<DD>Average storage size of each instance must be considered when setting chunk_size.
Indexing is as efficient as bounded, but insertion other than at the front
or back of a structure is less efficient than the unbounded form. 
<DT><B>Unbounded</B> 
<DD>Space efficient, but requires memory allocation for each new item added
(unless the storage management policy is &quot;Managed&quot;, see later discussions).
The most recently accessed item is cached. 
</DL>
<P>There is also variations for the presence of multiple threads of control.
A component can take on a form of Sequential, Guarded, or Synchronous. These
forms will be discussed later.


<!---------------------------------------------------------------------->


<A NAME="micro"> </A></P>
<H2>Micro Organization</H2>
<P>Each Abstract Base Class generally follows the same form of derivation: </P>
<PRE>
                         Abstract Base Class
                                 |
             +-------------------+----------------------+
     Bounded Form           Dynamic Form          Unbounded Form
     /       \                /      \              /        \
Guarded  Synchronized   Guarded  Synchronized   Guarded  Synchronized

</PRE>
<P>(Each level is a derivation via inheritance. Each class is a generic using
Item as the container parameter) 


<!---------------------------------------------------------------------->


 </P>
<H2><A NAME="timeandspace">Time and Space Semantics</A></H2>
<P>The fundamental difference between the Unbounded and Bounded forms is that
the unbounded form is essentially an time efficient linked-list, but is
not very space efficient. The bounded form uses a packed array base class,
which is space efficient, but can become time inefficient if adding items
into the middle of the array. </P>
<P>Bounded forms have two parameters for their generics: Item and Size. Dynamic
and Unbounded forms have Item and Storage_Manager for parameters. </P>
<P>


<!---------------------------------------------------------------------->


 </P>
<H2><A NAME="storage">Storage Management</A></H2>
<P>Storage management on certain architectures can be complex, and so requires
that all of our classes use a policy tailored to the platform, rather than
using a general one assumed by the library designer to work in all circumstances.
By clearly isolating these patterns of storage management, we can provide
a robust, adaptable library. </P>
<P>By treating the storage manager as an argument to all the dynamic and unbounded
concrete structures, we effectively decouple storage management policy from
its implementation, and make it possible for library users to insert their
own storage management policy without changing the library. This is a classic
example of extensibility through instantiation instead of inheritance. </P>

<P>The only requirement we place upon storage managers is that they provide
the same well-defined protocol. This is defined by the standard package
Ada.Storage_Pools.</p>

<p>Two predefined managers are available:
<dl>

<dt><tt>BC.Support.Unmanaged_Storage</tt></dt>
<dd>is effectively the default heap manager.</dd>

<dt><tt>BC.Support.Managed_Storage</tt></dt>
<dd>provides management of store within a pool whose unit (chunk) size
is specified when the pool is created.</dd>

</dl>
</p>

<p>Note that the supplied <tt>BC.Support.Managed_Storage</tt> will
<strong>not</strong> support allocation of items larger than its chunk
size.</p>

<!---------------------------------------------------------------------->


<A NAME="exceptions"> </A></P>
<H2>Exceptions</H2>
<P>All exceptions for the BCs are placed in the topmost package, BC. This precludes
the user from having to include a separate &quot;Exceptions&quot; package. Exception
behaviour of the BCs is standard and portable, unlike other languages. </p>

<p>As well as the exceptions from the C++ Components, an exception
<tt>Should_Have_Been_Overridden</tt> is possible. It will only be raised if the
implementor has forgotten to override a private subprogram of an
abstract class (such subprograms can't be abstract, see RM95 3.9.3(10)).</p>

<!----------------------------------------------------------------------> 


</P>
<H2><a name="iteration">Iteration<a/></H2>

Separate types act as agents responsible for iterating across a structure.
This was done for two reasons:

<UL>

<LI>By providing separate iterator types, we make it possible to
have several iterator objects working upon the same object.

<LI>Iteration slightly breaks the encapsulation of an object's state;
by separating the behaviour of iteration from the rest of an
abstraction's protocol, we provide a much cleaner separation of the
two.

</UL>

There are two forms: active and passive. Active iteration requires the client
explicitly advance the iterator. For passive, the client supplies a single
procedure <tt>Apply</tt> to work across the structure.<p>

In both forms, mechanisms are provided (where appropriate) to allow
access to the actual contained object rather than just to its
value.<p>

There are many different approaches to iteration in Ada 95. The current
mechanism was selected for its direct simplicity and efficiency. 


<!---------------------------------------------------------------------->


 </P>
<H2><A NAME="conclusion">Conclusion</A></H2>
<P>Here's a table of the components and the forms to be supported.<BR>
 (U=Unbounded, B=Bounded, D=dynamic, G=Guarded, S=Synchronized) </P>
<PRE>
Bags       : UBDGS
Collects   : UBDGS
Dequeues   : UBDGS
Graphs
  Directed : U
  Undir    : U
Lists
  Single   : U
  Double   : U
Maps       : UBDGS
Queues     : UBDGS
Rings      : UBDGS
Sets       : UBDGS
Stacks     : UBDGS
Sequences  : UBDGS
Trees
  AVL      : U
  Binary   : U
  Multiway : U
</PRE>
<P>

<font color=red>
<p>Here are the components presently available.</p>
<pre>
Bags       : U
Graphs
  Directed : U
  Undir    : U
Lists
  Single   : U
  Double   : U
Maps       : UBD
Queues     : UBD
Sets       : UBD
Stacks     : UBD
Trees
  AVL      : U
  Binary   : U
  Multiway : U
</pre>
</font>


<!--footer----------------------------------------------------------->


</P>
<P><IMG SRC="greenline.gif" ALT="--" WIDTH="600" HEIGHT="4"> </P>
<P><A HREF="index.html">[index]</A></p>

<p><i>
<script>
document.write("Last update: ");
document.write(document.lastModified);
</script>
<i></p>

<!------------------------------------------------------------------->

</BODY>
</HTML>
