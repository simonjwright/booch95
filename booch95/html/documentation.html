<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<HTML VERSION="2.0">
<HEAD>
<TITLE>The Ada95 Booch Components (Component documentation)</TITLE>
</HEAD>
<BODY BGCOLOR="#ffffff">

<table width="100%">
<tr>
<td><img src="ada95lgo.gif" alt="The (free) Ada95 Booch Components" >
<td align="right"><a href="http://sourceforge.net"><img src="http://sourceforge.net/sflogo.php?group_id=95861&amp;type=5" width="210" height="62" border="0" alt="SourceForge.net Logo"/></a>
</tr>
</table>

<p><I>Documentation</I> 

<p><img src="greenline.gif" alt="--" width="100%" height="4"> 

<p><A HREF="#abstractions">Key Abstractions</A><BR>
 <A HREF="#patterns">The Patterns of the BCs</A><BR>
 <A HREF="#tactical">Tactical Issues</A><BR>
 <A HREF="#macro">Macro Organization</A><BR>
 <A HREF="#families">Class Families</A><BR>
 <A HREF="#micro">Micro Organization</A><BR>
 <A HREF="#timeandspace">Time and Space Semantics</A><BR>
 <A HREF="#storage">Storage Management</A><BR>
 <A HREF="#exceptions">Exceptions</A><BR>
 <A HREF="#iteration">Iteration</A><BR>
 <A HREF="#support">Support packages</A><BR>
 <A HREF="#conclusion">Conclusion</A><BR>
 

<p><IMG SRC="greenline.gif" ALT="--" WIDTH="100%" HEIGHT="4"> 



<!---------------------------------------------------------------------->


<H2><A NAME="abstractions">Key Abstractions</A></H2>

<p>The Ada 95 version of the components contains the same key
abstractions as the C++ form (Structs, Tools and Support). However,
the organization is slightly different, particularly in the Support
domain. This is because Ada 95 provides several special forms of
memory management that are quite different from C++.

<p>The <B>Structs</B> category provides an array of structural
abstractions (Bags, Collections, Deques, Graphs, Lists, Maps, Queues,
Rings, Sets, Stacks, and Trees). The <B>Tools</B> category provides
algorithmic abstractions (Searching, Sorting, etc.). The
<B><a href="#support">Support</a></B> category contains all the
&quot;concrete&quot; forms, plus structures to create the components.

<p>Some of the structures permit structural sharing (graphs, lists,
and trees).  Some structures may also be ordered (collections,
dequeues, and queues).  There are also multiple forms for some
structures: single and double linked lists, directed and undirected
graphs, and binary, multiway, and AVL trees.


<!---------------------------------------------------------------------->


<H2><A NAME="patterns">The Patterns of the BCs</A></H2>

<p>The BCs cover several issues: 

<UL>

<LI>Time and Space semantics

<LI>Storage Management policies

<LI>Exceptions

<LI>Idioms for iteration

</UL>

<p>These patterns have evolved in a way that each language feature is used
in an efficient and appropriate manner, with the overall goal of balancing
usability and extensibility.


<!---------------------------------------------------------------------->


<H2><A NAME="tactical">Tactical Issues</A></H2>

<BLOCKQUOTE>The particular semantics of a given programming language
influence our architectural decisions. To ignore these influences
leaves us with abstractions that do not take advantage of the
language's unique features, or with mechanisms that cannot be
efficiently implemented. -- <I>G. Booch</I> </BLOCKQUOTE>

<p>Ada 95 inherently provides several features not present in C++:
safe generics, safe object-oriented programming (no silent "object
slicing"), general access types and access discriminants, and
concurrency support.  All this as well as user-definable storage
management, automatic reclamation of resources (garbage collection
&quot;lite&quot;), aggregation, inheritance, and parameterization
available in C++ and other languages.

<p>The BCs take advantage of several critical forms of structuring:
inheritance, parameterization, modularity, and aggregation. Of these
forms, parameterization is the form most often used.


<!---------------------------------------------------------------------->


<H2><A NAME="macro">Macro Organization</A></H2>

<p>The BCs emphasize separation of policy from implementation. For
this reason, abstract classes are declared for every major component
type. Also, the Support category provides the common low-level
features used in constructing the different components, in order to
help the &quot;power user&quot; create new components or extend
existing ones.

<p>An example:<BR>

A Mail_Queue is an instance of a Priority_Event_Queue, which itself is
a generic instantiated with Network_Event as the item it contains. The
Priority_Event_Queue is derived from Queue.


<!---------------------------------------------------------------------->


<H2><a name="families">Class Families</a></H2>

<p>Each abstract base class has several derived concrete forms, each
designed to support specific needs for time and space semantics. The
user selects the concrete form most appropriate to their needs. The
net result is that copy, assignment, and equality operations work
between each different form of the components. 

<p>There are two very common variations of structure management:
bounded and unbounded. A third form was added to the latest BCs:
dynamic. This form represents a heap structure which behaves
(basically) as a dynamic array.  Its performance lies between that of
a bounded and unbounded structure.  The array can grow or shrink in
multiples of a chunk_size. <i>[Note, this becomes less valuable given
Ada's support for user-defined storage pools.]</i>

<p>The selection rules are: 

<DL>

<DT><B>Bounded</B>

<DD>Use where size is statically known or allocation from the heap is
prohibited.

<DT><B>Dynamic</B>

<DD>Average storage size of each instance must be considered when
setting chunk_size.  Indexing is as efficient as bounded, but
insertion other than at the front or back of a structure is less
efficient than the unbounded form. Storage is allocated by a <a
href="#storage">storage manager</a>.

<DT><B>Unbounded</B>

<DD>Space efficient, but requires memory allocation for each new item
added, under the control of a <a href="#storage">storage manager</a>.
The most recently accessed item is cached.

<DT><B>Unmanaged</B>

<DD>Space efficient, but requires memory allocation for each new item
added, from the system's memory pool.  The most recently accessed item
is cached.

</DL>


<!---------------------------------------------------------------------->


<H2><A NAME="micro">Micro Organization</A></H2>

<p>Each Abstract Base Class generally follows the same form of
derivation:

<img src="organization.png" alt="Picture of organisation of classes">

<p>(Each level is a derivation via inheritance. Each class is a
generic using Item as the container parameter)

<!---------------------------------------------------------------------->


 
<H2><A NAME="timeandspace">Time and Space Semantics</A></H2>

<p>The fundamental difference between the Unbounded and Bounded forms
is that the unbounded form is essentially an time efficient
linked-list, but is not very space efficient. The bounded form uses a
packed array base class, which is space efficient, but can become time
inefficient if adding items into the middle of the array. 

<p>Bounded forms have two parameters for their generics: Item and
Maximum_Size. Dynamic and Unbounded forms have Item and the actual
Storage Pool for parameters. 



<!---------------------------------------------------------------------->


<H2><A NAME="storage">Storage Management</A></H2>

<p>Storage management on certain architectures can be complex, and so
requires that all of our classes use a policy tailored to the
platform, rather than using a general one assumed by the library
designer to work in all circumstances. By clearly isolating these
patterns of storage management, we can provide a robust, adaptable
library.

<p>By treating the storage manager as an argument to all the dynamic
and unbounded concrete structures, we effectively decouple storage
management policy from its implementation, and make it possible for
library users to insert their own storage management policy without
changing the library. This is a classic example of extensibility
through instantiation instead of inheritance. 

<p>The only requirement we place upon storage managers is that they
provide the same well-defined protocol. This is defined by the
standard package Ada.Storage_Pools.

<p>Two predefined managers are available:

<dl>

<dt><tt>BC.Support.Standard_Storage.Pool</tt></dt>

<dd>is effectively the default heap manager.</dd>

<dt><tt>BC.Support.Managed_Storage.Pool (Chunk_Size)</tt></dt>

<dd>provides management of store within a pool whose unit (chunk) size
is specified when the pool is created.</dd>

</dl>

<p>Note that the supplied <tt>BC.Support.Managed_Storage</tt> will
<strong>not</strong> support allocation of items larger than its chunk
size.

<p>For those who don't need this level of control, we provide
<i>Unmanaged</i> forms.

<!---------------------------------------------------------------------->


<H2><A NAME="exceptions">Exceptions</A></H2>

<p>All exceptions for the BCs are declared in the topmost package,
BC. This precludes the user from having to include a separate
&quot;Exceptions&quot; package. Exception behaviour of the BCs is
standard and portable, unlike other languages.

<p>As well as the exceptions from the C++ Components, an exception
<tt>Should_Have_Been_Overridden</tt> is possible. It will only be
raised if the implementor has forgotten to override a private
subprogram of an abstract class (such subprograms can't be abstract,
see RM95 3.9.3(10)).

<!---------------------------------------------------------------------->


<H2><a name="iteration">Iteration<a/></H2>

<p>Separate types act as agents responsible for iterating across a structure.
This was done for two reasons:

<UL>

<LI>By providing separate iterator types, we make it possible to have
several iterator objects working upon the same object.

<LI>Iteration slightly breaks the encapsulation of an object's state;
by separating the behaviour of iteration from the rest of an
abstraction's protocol, we provide a much cleaner separation of the
two.

</UL>

<p>There are two forms: active and passive. Active iteration requires
the client explicitly advance the iterator. For passive, the client
supplies a single procedure <tt>Apply</tt> to work across the
structure.

<p>In both forms, mechanisms are provided (where appropriate) to allow
access to the actual contained object rather than just to its
value.

<p>There are many different approaches to iteration in Ada 95. The
current mechanism was selected for its direct simplicity and
efficiency.


<!---------------------------------------------------------------------->


<h2><a name="support">Support</a></h2>

<p>The support packages (<tt>BC.Support</tt> and children) come in two
flavours:

<ul>

<li>support for the Containers, and

<li>general utilities.

</ul>

<p>The general utilities are:

<dl>

<dt><tt>High_Resolution_Time</tt><dd>Supports high resolution
(sub-microsecond) time measurements.
<br>The only implementation provided is for GNAT on Intel x86 targets
(Linux, Windows).

<dt><tt>Managed_Storage</tt><dd>A storage pool by <a
href="mailto:pat@classwide.com">Pat Rogers</a>, which can allocate
objects up to a user-defined size (supplied as a constraint).

<dt><tt>Memory_Streams</tt><dd>Support streaming to memory.

<dt><tt>Smart_Pointers</tt><dd>Provide reference-counting pointers.

<dt><tt>Standard_Storage</tt><dd>Interface to the standard storage
pool (works for GNAT, ObjectAda, may work on others).

<dt><tt>Statistics</tt><dd>Supports on-the-fly calculation of
mean, minimum and maximum values, variance, and standard deviation of
sets of values.

<dt><tt>Synchronization</tt><dd>The Components don't provide forms
that are directly suitable for use in concurrent programs. This is
mainly because it's not possible to support all the ways that people
might want to use them.

<br>You'll probably want to use the Components to implement your own
abstractions, so it's best to provide your own wrappers using
protected types and tasks as needed.

<br>This package provides Semaphores and Monitors which may be helpful.

<dt><tt>Unmanaged_Storage</tt><dd>A storage pool by <a
href="mailto:pat@classwide.com">Pat Rogers</a>, implemented using the
default storage pool (works for GNAT, ObjectAda, Apex, may work on
others).

</dl>


<!---------------------------------------------------------------------->


<H2><A NAME="conclusion">Conclusion</A></H2>

<p>Here's a table of the components and the forms that are supported
(U=Unbounded, B=Bounded, D=Dynamic, N=Unmanaged).

<PRE>
Bags         : <font color="red">UBDN</font>
Collections  : <font color="red">UBDN</font>
  (ordered)  : <font color="red">UBDN</font>
Dequeues     : <font color="red">UBDN</font>
Graphs
  Directed   : <font color="red">U</font>
  Undirected : <font color="red">U</font>
Lists
  Single     : <font color="red">U</font>
  Double     : <font color="red">U</font>
Maps         : <font color="red">UBDN</font>
Queues       : <font color="red">UBDN</font>
  (ordered)  : <font color="red">UBDN</font>
Rings        : <font color="red">UBDN</font>
Sets         : <font color="red">UBDN</font>
Stacks       : <font color="red">UBDN</font>
Trees
  AVL        : <font color="red">U</font>
  Binary     : <font color="red">U</font>
  Multiway   : <font color="red">U</font>
</PRE>


<!--footer----------------------------------------------------------->



<p><IMG SRC="greenline.gif" ALT="--" WIDTH="100%" HEIGHT="4"> 
<p><A HREF="index.html">[index]</A>

<p><i>
<script>
document.write("Last update: ");
document.write(document.lastModified);
</script>
<i>

<!------------------------------------------------------------------->

</BODY>
</HTML>
