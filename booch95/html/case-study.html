<!-- $Id$ -->
<html>
<head>
<title>The Ada95 Booch Components (Case Study)</title>
</head>
<body bgcolor="#ffffff">
<h1><img src="ada95lgo.gif" alt="The Ada 95 Booch Components"></h1>
<i>Case Study</i>

<p>The Booch Components are a complex whole, and the purpose of this
note is to provide an initial introduction to their use.

<p><img src="greenline.gif" alt="--" width="600" height="4"> </p>

<ul>
<li><a href="#example">The example</a>
<li><a href="#which-components">Which components to use?</a>
<li><a href="#instantiation">How do I instantiate them?</a>
<li><a href="#what-to-do">What can I do with them?</a>
<li><a href="#other-components">What other Components might be useful?</a>
<li><a href="#forms">What are these "Forms"?</a>
</ul>

<p><img src="greenline.gif" alt="--" width="600" height="4"> </p>

<h2><a name="example">The example</a></h2>

<img src="car-fleet.jpg" alt="Car belongs to Fleet"/>

<p>In the example, a Car has three attributes, the Plate (the Index
Mark; my first car's was <tt>8493KC</tt>), the Model name (it was a
Vauxhall Cresta) and the date it was Registered (some time in the
mists of antiquity).

<pre>
   with Ada.Calendar;
   with Ada.Strings.Bounded;
   package Cars is

      package Plate_Strings
      is new Ada.Strings.Bounded.Generic_Bounded_Length (10);
      subtype Plate_String
      is Plate_Strings.Bounded_String;

      package Model_Strings
      is new Ada.Strings.Bounded.Generic_Bounded_Length (32);
      subtype Model_String
      is Model_Strings.Bounded_String;

      type Car is record
	 Plate : Plate_String;
	 Model : Model_String;
	 Registered : Ada.Calendar.Time;
      end record;

   end Cars;
</pre>

<p>A company's Fleet holds a number of Cars.

<h2><a name="which-components">Which components to use?</a></h2>

<p>You're clearly going to need some sort of container to implement
Fleet.

<p>If you just want a standard container to support iteration,
filtering and sorting, use Collections. The List components are much
more complex than you'll need.

<p>Later, we'll look at Maps.

<h2><a name="instantiation">How do I instantiate them?</a></h2>

<h3><a name="separate-instantiation">Separate instantiation</a></h3>

<p>The first thing to do is to instantiate the top-level abstract
Containers for Car. Note, you have to supply an equality operator
(<tt>"="</tt>) for <tt>Car</tt>; you could also just <tt>use</tt>
<tt>Cars</tt>.

<pre>
   with BC.Containers;
   with Cars;
   package Abstract_Car_Containers
   is new BC.Containers (Cars.Car, "=" => Cars."=");
</pre>

<p>Next, using the new Abstract_Car_Containers, instantiate the
abstract Collections. This is quite confusing the first few times you
come across it! The thing you have to instantiate is not
<tt>BC.Containers.Collections</tt> but the new <tt><i>instantiation of
BC.Containers</i>.Collections</tt>
(<tt>Abstract_Car_Containers.Collections</tt>) that you effectively
made above:

<pre>
   with Abstract_Car_Containers;
   with BC.Containers.Collections;
   package Abstract_Car_Collections
   is new Abstract_Car_Containers.Collections;
</pre>

<p>You now have to choose the representation to be used for the
concrete Collection. To start with, assume that you'll never have more
than 30 Cars to deal with. This means that you can use the Bounded
form. Again, what you instantiate is the child of the newly
instantiated <tt>Abstract_Car_Collections</tt>.

<pre>
   with Abstract_Car_Collections;
   with BC.Containers.Collections.Bounded;
   package Fleets
   is new Abstract_Car_Collections.Bounded (Maximum_Size => 30);
</pre>

You now need to create your Fleet:

<pre>
   with Fleets;
   package My_Fleet is

      The_Fleet : Fleets.Collection;

   end My_Fleet;
</pre>

<h3>Grouped instantiation</h3>

<p>You might find it more convenient to do the instantiations in one
place. Note the <tt>use type Cars.Car;</tt> to make
<tt>Car</tt> equality visible:

<pre>
   with BC.Containers.Collections.Bounded;
   with Cars;
   package <a name="fleet-combined">My_Fleet_Combined</a> is

      use type Cars.Car;

      package Abstract_Car_Containers
      is new BC.Containers (Cars.Car);

      package Abstract_Car_Collections
      is new Abstract_Car_Containers.Collections;

      package Fleets
      is new Abstract_Car_Collections.Bounded (Maximum_Size => 30);

      The_Fleet : Fleets.Collection;

   end My_Fleet_Combined;
</pre>

<p>or even to make the use of the Components private:

<pre>
   with BC.Containers.Collections.Bounded;
   with Cars;
   package <a name="fleet-hidden">My_Fleet_Hidden</a> is

      --  subprograms to add, find, and delete Cars

   private

      package Abstract_Car_Containers
      is new BC.Containers (Cars.Car, "=" => Cars."=");

      package Abstract_Car_Collections
      is new Abstract_Car_Containers.Collections;

      package Fleets
      is new Abstract_Car_Collections.Bounded (Maximum_Size => 30);

      The_Fleet : Fleets.Collection;

   end My_Fleet_Hidden;
</pre>

<h2><a name="what-to-do">What can I do with them?</a></h2>

<p>Aside from keeping things in Collections, there are other
possibilities:

<ul>
<li><a href="#iteration">iteration</a>,
<li><a href="#selection">selection</a>, and
<li><a href="#sorting">sorting</a>.
</ul>

<h3><a name="iteration">Iteration</a></h3>

<p>Iteration is the process of visiting each member of a collection
and doing something with or to it.

<p>Two forms of iteration are supported: open and closed. Both require
the creation of Iterators.

<p>With open iterators, you explicitly advance
the iterator to the next element in the collection it references,
until it's done; with closed iterators, you supply a procedure which
gets called for each element in the collection.

<p>Considering the packages declared in the discussion on <a
href="#separate-instantiation">separate instantiation</a> above, the
operations on iterators are all defined in
<tt>Abstract_Car_Containers</tt>, while actual iterators can only be
created by the concrete package:

<pre>
   declare

      It : Abstract_Car_Containers.Iterator'Class
        := Fleets.New_Iterator (The_Fleet);

   begin

      while not Abstract_Car_Containers.Is_Done (It) loop

         declare
            C : Car := Abstract_Car_Containers.Current_Item (It);
         begin
            null;  --  do something with C
         end;

         Abstract_Car_Containers.Next (It);

      end loop;

   end;
</pre>

<o>A closed-iterator version of the same would look like

<pre>
   declare

      procedure Process_Car (C : Car; OK : out Boolean);

      procedure Process_Fleet
        is new Abstract_Car_Containers.Visit (Process_Car);

      procedure Process_Car (C : Car; OK : out Boolean) is
      begin

         OK := True;  --  unless you want the iteration to stop early

         --  do something with C

      end Process_Car;

      It : Abstract_Car_Containers.Iterator'Class
        := Fleets.New_Iterator (The_Fleet);

   begin

      Process_Fleet (It);

   end;
</pre>

<p>This example uses the generic <tt>Visit</tt>, which takes the
element to be processed as an <tt>in</tt> parameter. As well as this,
there's the generic <tt>Modify</tt>, which takes the element as an
<tt>in&nbsp;out</tt> parameter.

<p>Both <tt>Visit</tt> and <tt>Modify</tt> come in three flavours:

<ul>
<li>plain
<li>with an additional <tt>in</tt> parameter
<li>with an additional <tt>in&nbsp;out</tt> parameter.
</ul>

<p>See <tt>BC.Containers</tt> for details.

<h3><a name="selection">Selection</a></h3>

<p>Suppose you want to find all the Cars in our Fleet that were
registered before some date. You could imagine a function
<tt>Before</tt>:

<pre>
   function Before (Date : Ada.Calendar.Time) return Fleets.Collection;
</pre>

which you'd probably declare in the public part of <a
href="#fleet-combined"><tt>My_Fleet_Combined</tt></a>. Its body might
look like
 
<pre>
   function Before (Date : Ada.Calendar.Time) return Fleets.Collection is

      function Wanted (C : Car) return Boolean;

      procedure Choose is new BC.Filter
        (Item => Car,
         Source => Abstract_Car_Containers,
         From => Fleets.Collection,
         Target => Abstract_Car_Containers,
         To => Fleets.Collection,
         Pass => Wanted,
         Clear => Fleets.Clear,
         Add => Fleets.Append);

      function Wanted (C : Car) return Boolean is
         use type Ada.Calendar.Time;
      begin
         return C.Registered < Date;
      end Wanted;

      Result : Fleets.Collection;

   begin
      Choose (The_Fleet, Result);
      return Result;
   end Before;
</pre>

which is a bit of a mouthful.

<p>The tricky bit is the instantiation of <tt>BC.Filter</tt> (which,
of course, you have to <tt>with</tt>):

<blockquote>
<dl>

<dt><tt>Item</tt><dd>is the thing you're filtering (<tt>Car</tt>),

<dt><tt>Source</tt><dd>is an instantion of <tt>BC.Containers</tt> with
<tt>Item</tt>s,

<dt><tt>From</tt><dd>is the concrete Container type which contains the
<tt>Item</tt>s to be filtered; it has to have beeen derived from the
abstract <tt>Container</tt> in <tt>Source</tt>,

<dt><tt>Target</tt><dd>is a (possibly different) instantion of
<tt>BC.Containers</tt> with <tt>Item</tt>s,

<dt><tt>To</tt><dd>is the concrete Container type which is to receive
the <tt>Item</tt>s when they have been filtered; it has to have been
derived from the abstract <tt>Container</tt> in <tt>Target</tt>, and
may or may not be the same as <tt>From</tt>,

<dt><tt>Pass</tt><dd>is a function which takes an <tt>Item</tt> and
returns <tt>True</tt> if it's to be kept. In this case, this is
<tt>Wanted</tt>,

<dt><tt>Clear</tt><dd>is a procedure which empties a <tt>To</tt>
Container,

<dt><tt>Add</tt><dd>is a procedure which adds an <tt>Item</tt> to a
<tt>To</tt> Container.

</dl>
</blockquote>

<h3><a name="sorting">Sorting</a></h3>

<p>Suppose you want to keep your Fleet sorted (earliest first). You
need

<pre>
  procedure Sort;
</pre>

which, as before, gets declared in the public part of <a
href="#fleet-combined"><tt>My_Fleet_Combined</tt></a>.

<pre>
   procedure Sort is

      function Earlier (L, R : Car) return Boolean;

      procedure Sort is new Abstract_Car_Containers.Quicksort
        ("<" => Earlier,
         Container => Fleets.Collection,
         Length => Fleets.Length);

      function Earlier (L, R : Car) return Boolean is
         use type Ada.Calendar.Time;
      begin
         return L.Registered < R.Registered;
      end Earlier;

   begin
      Sort (The_Fleet);
   end Sort;
</pre>

As before, you "with" <tt>BC.Containers.Quicksort</tt>, but when
you do the instantiation it's of
<tt>Abstract_Car_Containers.Quicksort</tt>.

<p>As an alternative to Quicksort you can use
<tt>BC.Containers.Shellsort</tt>; the quicksort is (usually) quicker
but uses recursion, so may take more stack space.

<h2><a name="other-components">What other Components might be
useful?</a></h2>

<p><i>This will be a discussion of Maps and Sets, I think, with a
passing glance at Queues.</i>

<h2><a name="forms">What are these "Forms"?</a></h2>

<p><i>This will be a discussion of Bounded vs Dynamic vs Unbounded. I
guess it should cover Storage Management as well.</i>

<p><img src="greenline.gif" alt="--" width="600" height="4"> </p>

<p><a href="index.html">[index]</a></p>

<p><i>
<script>
document.write("Last update: ");
document.write(document.lastModified);
</script>
</i></p>
</body>
</html>
